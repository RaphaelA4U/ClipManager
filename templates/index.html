<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ClipManager</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="icon" href="/static/img/favicon.ico" type="image/x-icon">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css" rel="stylesheet">
    <!-- Replace the old Google API script with the new Google Identity Services library -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo-container">
                <img src="/static/img/ClipManager.png" alt="ClipManager Logo">
            </div>
             
            <div class="header-controls">
                <button id="fullscreenBtn" class="fullscreen-btn" title="Enter Fullscreen">
                    <i class="mdi mdi-fullscreen"></i>
                </button>
            </div>
        </div>

        <div class="page-content">
            <div class="tabs">
                <div class="tab active" data-tab="form-tab">Configuration</div>
                <div class="tab" data-tab="clips-tab">Clips</div>
            </div>

            <div id="form-tab" class="tab-content active">
                <form id="clipForm">
                    <div class="form-group">
                        <label>Backtrack Seconds:</label>
                        <input type="number" id="backtrack_seconds" value="10" min="0" max="300">
                    </div>
                    <div class="form-group">
                        <label>Duration Seconds:</label>
                        <input type="number" id="duration_seconds" value="10" min="1" max="300">
                    </div>
                    <div class="form-group">
                        <label>Chat App(s):</label>
                        <div class="chat-app-selector">
                            <label><input type="checkbox" class="chat-app-checkbox" value="telegram"> Telegram</label>
                            <label><input type="checkbox" class="chat-app-checkbox" value="mattermost"> Mattermost</label>
                            <label><input type="checkbox" class="chat-app-checkbox" value="discord"> Discord</label>
                            <label><input type="checkbox" class="chat-app-checkbox" value="sftp"> SFTP</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Title (optional):</label>
                        <input type="text" id="title">
                    </div>
                    <div class="form-group">
                        <label>Category (optional):</label>
                        <input type="text" id="category">
                    </div>
                    <div class="form-group">
                        <label>Team 1 (optional):</label>
                        <input type="text" id="team1">
                    </div>
                    <div class="form-group">
                        <label>Team 2 (optional):</label>
                        <input type="text" id="team2">
                    </div>
                    <div class="form-group">
                        <label>Additional Text (optional):</label>
                        <input type="text" id="additional_text">
                    </div>

                    <!-- Dynamic fields that will appear based on selected chat apps -->
                    <div id="chat-app-fields">
                        <!-- Telegram fields -->
                        <div id="telegram-fields" class="chat-app-fields" style="display: none;">
                            <h3>Telegram Settings</h3>
                            <div class="form-group">
                                <label>Bot Token:</label>
                                <input type="text" id="telegram_bot_token">
                            </div>
                            <div class="form-group">
                                <label>Chat ID:</label>
                                <input type="text" id="telegram_chat_id">
                            </div>
                        </div>
                        
                        <!-- Mattermost fields -->
                        <div id="mattermost-fields" class="chat-app-fields" style="display: none;">
                            <h3>Mattermost Settings</h3>
                            <div class="form-group">
                                <label>Mattermost URL:</label>
                                <input type="text" id="mattermost_url" placeholder="https://mattermost.example.com">
                            </div>
                            <div class="form-group">
                                <label>API Token:</label>
                                <input type="text" id="mattermost_token">
                            </div>
                            <div class="form-group">
                                <label>Channel ID:</label>
                                <input type="text" id="mattermost_channel">
                            </div>
                        </div>
                        
                        <!-- Discord fields -->
                        <div id="discord-fields" class="chat-app-fields" style="display: none;">
                            <h3>Discord Settings</h3>
                            <div class="form-group">
                                <label>Webhook URL:</label>
                                <input type="text" id="discord_webhook_url" placeholder="https://discord.com/api/webhooks/id/token">
                            </div>
                        </div>
                        
                        <!-- SFTP fields -->
                        <div id="sftp-fields" class="chat-app-fields" style="display: none;">
                            <h3>SFTP Settings</h3>
                            <div class="form-group">
                                <label>SFTP Host:</label>
                                <input type="text" id="sftp_host">
                            </div>
                            <div class="form-group">
                                <label>SFTP Port (default: 22):</label>
                                <input type="text" id="sftp_port" placeholder="22">
                            </div>
                            <div class="form-group">
                                <label>SFTP Username:</label>
                                <input type="text" id="sftp_user">
                            </div>
                            <div class="form-group">
                                <label>SFTP Password:</label>
                                <input type="password" id="sftp_password">
                            </div>
                            <div class="form-group">
                                <label>Remote Path (optional):</label>
                                <input type="text" id="sftp_path" placeholder="./">
                            </div>
                        </div>
                        
                        <!-- YouTube fields -->
                        <div class="chat-app-fields">
                            <h3>YouTube Account</h3>
                            <div class="form-group">
                                <p>Upload videos directly to your YouTube channel.</p>
                                <div class="youtube-buttons">
                                    <button type="button" id="signInYouTube" class="btn-primary">Connect YouTube Account</button>
                                    <button type="button" id="signOutYouTube" class="btn-secondary">Sign Out</button>
                                </div>
                                <div id="ytStatus" style="margin-top: 10px;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <button type="button" id="saveBtn">Save</button>
                    <button type="button" id="recordBtn">Record Clip</button>        
                </form>
            </div>

            <div id="clips-tab" class="tab-content">
                <div id="sftp-config" class="section">
                    <h3>SFTP Server Settings</h3>
                    <p>Configure the SFTP server where your clips are stored.</p>
                    <form id="sftpForm">
                        <div class="form-group">
                            <label>SFTP Host:</label>
                            <input type="text" id="sftp_host_config">
                        </div>
                        <div class="form-group">
                            <label>SFTP Port:</label>
                            <input type="text" id="sftp_port_config" placeholder="22">
                        </div>
                        <div class="form-group">
                            <label>SFTP Username:</label>
                            <input type="text" id="sftp_user_config">
                        </div>
                        <div class="form-group">
                            <label>SFTP Password:</label>
                            <input type="password" id="sftp_password_config">
                        </div>
                        <div class="form-group">
                            <label>Remote Path:</label>
                            <input type="text" id="sftp_path_config" placeholder="./">
                        </div>
                        <div class="sftp-controls">
                            <button type="button" id="saveSftpBtn">Save SFTP Settings</button>
                            <button type="button" id="testSftpBtn">Test Connection</button>
                        </div>
                    </form>
                </div>
                
                <div id="clips-section" class="section" style="display: none;">
                    <div class="section-header">
                        <h3>Clips</h3>
                        <button id="refreshClipsBtn"><span class="spinner" style="display: none;"></span>Refresh</button>
                    </div>
                    <div class="filter-group">
                        <div class="form-group">
                            <label>Title:</label>
                            <input type="text" id="filter_title" placeholder="Filter by title">
                        </div>
                        <div class="form-group">
                            <label>Category:</label>
                            <input type="text" id="filter_category" placeholder="E.g. highlight">
                        </div>
                        <div class="form-group">
                            <label>Team:</label>
                            <input type="text" id="filter_team" placeholder="E.g. team1 or team2">
                        </div>
                        <div class="form-group">
                            <label>Start Date:</label>
                            <input type="date" id="filter_start_date">
                        </div>
                        <div class="form-group">
                            <label>End Date:</label>
                            <input type="date" id="filter_end_date">
                        </div>
                        <button id="applyFilterBtn">Apply Filter</button>
                        <button id="resetFilterBtn">Reset</button>
                    </div>
                    <div id="clips-loading" class="clips-loading" style="display: none;">
                        <span class="spinner"></span> Loading clips...
                    </div>
                    <div id="clips-list" class="clips-list"></div>
                    <div id="pagination" class="pagination"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="clip-player-container" style="display: none;">
        <video id="clip-player" controls></video>
        <button class="close-player">&times;</button>
    </div>

    <script>
        let savedData = null;
        let sftpSettings = null;
        let allClips = [];
        let filteredClips = [];
        let currentPage = 1;
        const itemsPerPage = 12;
        let ws = null;
        let pollingInterval = null;
        let isFullscreen = false;

        function collectFormData() {
            const selectedApps = [];
            document.querySelectorAll('.chat-app-checkbox:checked').forEach(checkbox => {
                selectedApps.push(checkbox.value);
            });

            const data = {
                backtrack_seconds: parseInt(document.getElementById('backtrack_seconds').value) || 10,
                duration_seconds: parseInt(document.getElementById('duration_seconds').value) || 10,
                chat_app: selectedApps.join(','),
                title: document.getElementById('title').value,
                category: document.getElementById('category').value,
                team1: document.getElementById('team1').value,
                team2: document.getElementById('team2').value,
                additional_text: document.getElementById('additional_text').value
            };

            if (selectedApps.includes('telegram')) {
                data.telegram_bot_token = document.getElementById('telegram_bot_token').value;
                data.telegram_chat_id = document.getElementById('telegram_chat_id').value;
            }

            if (selectedApps.includes('mattermost')) {
                data.mattermost_url = document.getElementById('mattermost_url').value;
                data.mattermost_token = document.getElementById('mattermost_token').value;
                data.mattermost_channel = document.getElementById('mattermost_channel').value;
            }

            if (selectedApps.includes('discord')) {
                data.discord_webhook_url = document.getElementById('discord_webhook_url').value;
            }
            
            if (selectedApps.includes('sftp')) {
                data.sftp_host = document.getElementById('sftp_host').value;
                data.sftp_port = document.getElementById('sftp_port').value;
                data.sftp_user = document.getElementById('sftp_user').value;
                data.sftp_password = document.getElementById('sftp_password').value;
                data.sftp_path = document.getElementById('sftp_path').value;
            }

            return data;
        }

        function loadSavedData() {
            const saved = localStorage.getItem('configSettings');
            if (saved) {
                try {
                    savedData = JSON.parse(saved);
                    
                    // Populate form fields with saved data
                    document.getElementById('backtrack_seconds').value = savedData.backtrack_seconds || 10;
                    document.getElementById('duration_seconds').value = savedData.duration_seconds || 10;
                    document.getElementById('title').value = savedData.title || '';
                    document.getElementById('category').value = savedData.category || '';
                    document.getElementById('team1').value = savedData.team1 || '';
                    document.getElementById('team2').value = savedData.team2 || '';
                    document.getElementById('additional_text').value = savedData.additional_text || '';
                    
                    // Handle chat apps
                    const chatApps = savedData.chat_app ? savedData.chat_app.split(',') : [];
                    document.querySelectorAll('.chat-app-checkbox').forEach(checkbox => {
                        checkbox.checked = chatApps.includes(checkbox.value);
                        const fields = document.getElementById(checkbox.value + '-fields');
                        if (fields) {
                            fields.style.display = checkbox.checked ? 'block' : 'none';
                        }
                    });
                    
                    // Populate app-specific fields
                    if (chatApps.includes('telegram')) {
                        document.getElementById('telegram_bot_token').value = savedData.telegram_bot_token || '';
                        document.getElementById('telegram_chat_id').value = savedData.telegram_chat_id || '';
                    }
                    
                    if (chatApps.includes('mattermost')) {
                        document.getElementById('mattermost_url').value = savedData.mattermost_url || '';
                        document.getElementById('mattermost_token').value = savedData.mattermost_token || '';
                        document.getElementById('mattermost_channel').value = savedData.mattermost_channel || '';
                    }
                    
                    if (chatApps.includes('discord')) {
                        document.getElementById('discord_webhook_url').value = savedData.discord_webhook_url || '';
                    }
                    
                    if (chatApps.includes('sftp')) {
                        document.getElementById('sftp_host').value = savedData.sftp_host || '';
                        document.getElementById('sftp_port').value = savedData.sftp_port || '';
                        document.getElementById('sftp_user').value = savedData.sftp_user || '';
                        document.getElementById('sftp_password').value = savedData.sftp_password || '';
                        document.getElementById('sftp_path').value = savedData.sftp_path || '';
                    }
                    
                    // Show integration section if config is loaded
                    updateIntegrationSection();
                } catch (e) {
                    console.error("Error loading configuration settings:", e);
                    localStorage.removeItem('configSettings');
                }
            }
        }

        function updateIntegrationSection() {
            if (!savedData) return;
            
            // Create or update integration section
            let integrationSection = document.getElementById('integration-section');
            
            if (!integrationSection) {
                // Create the section if it doesn't exist
                integrationSection = document.createElement('div');
                integrationSection.id = 'integration-section';
                integrationSection.className = 'section';
                
                const formTab = document.getElementById('form-tab');
                formTab.appendChild(integrationSection);
            }
            
            // Update content
            const url = new URL('/api/clip', window.location.origin);
            for (const [k, v] of Object.entries(savedData)) {
                if (v !== '' && v !== false) {
                    url.searchParams.set(k, v);
                }
            }
            
            // Escape HTML tags for display
            const buttonCode = `<button onclick="fetch('${url}',{method:'GET'}).then(r=>r.text()).then(alert)">Record Clip</button>`;
            
            integrationSection.innerHTML = `
                <h3>Integration Options</h3>
                <div class="section">
                    <h4>HTML Button Code</h4>
                    <div class="code-container">
                        <pre id="htmlCode">${buttonCode.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                        <button class="copy-btn" data-target="htmlCode">Copy</button>
                    </div>
                </div>
                <div class="section">
                    <h4>cURL Command</h4>
                    <div class="code-container">
                        <pre id="curlCode">curl "${url.toString()}"</pre>
                        <button class="copy-btn" data-target="curlCode">Copy</button>
                    </div>
                </div>
            `;
            
            // Re-attach copy button event listeners
            document.querySelectorAll('.copy-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const text = document.getElementById(targetId).textContent;
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            const original = this.textContent;
                            this.textContent = 'Copied!';
                            setTimeout(() => { this.textContent = original; }, 1500);
                        });
                });
            });
        }

        function recordClip() {
            const formData = collectFormData();
            
            // Validate required fields
            const errors = [];
            
            // Check backtrack_seconds
            if (!formData.backtrack_seconds || formData.backtrack_seconds < 0 || formData.backtrack_seconds > 300) {
                errors.push("Backtrack must be between 0 and 300 seconds");
            }
            
            // Check duration_seconds
            if (!formData.duration_seconds || formData.duration_seconds < 1 || formData.duration_seconds > 300) {
                errors.push("Duration must be between 1 and 300 seconds");
            }
            
            // Check that at least one chat app is selected
            if (!formData.chat_app) {
                errors.push("Please select at least one destination for your clip");
            }
            
            // Validate platform-specific required fields
            if (formData.chat_app.includes('telegram')) {
                if (!formData.telegram_bot_token || !formData.telegram_chat_id) {
                    errors.push("Telegram requires both Bot Token and Chat ID");
                }
            }
            
            if (formData.chat_app.includes('mattermost')) {
                if (!formData.mattermost_url || !formData.mattermost_token || !formData.mattermost_channel) {
                    errors.push("Mattermost requires URL, API Token, and Channel ID");
                }
            }
            
            if (formData.chat_app.includes('discord')) {
                if (!formData.discord_webhook_url) {
                    errors.push("Discord requires a Webhook URL");
                }
            }
            
            if (formData.chat_app.includes('sftp')) {
                if (!formData.sftp_host || !formData.sftp_user || !formData.sftp_password) {
                    errors.push("SFTP requires Host, Username, and Password");
                }
            }
            
            // Show errors if any
            if (errors.length > 0) {
                alert(errors.join(". "));
                return;
            }
            
            const url = new URL('/api/clip', window.location.origin);
            for (const [key, value] of Object.entries(formData)) {
                if (value !== '' && value !== false) {
                    url.searchParams.set(key, value);
                }
            }

            fetch(url.toString(), {
                method: 'GET',
                headers: {
                    'Accept': 'application/json'
                }
            })
            .then(resp => {
                if (resp.ok) {
                    return resp.json().catch(() => ({ message: 'Response OK but not JSON' }));
                } else {
                    return resp.text().then(text => Promise.reject(text));
                }
            })
            .then(data => {
                alert('Clip recording and sending started successfully!');
            })
            .catch(err => {
                alert('Error: ' + err);
            });
        }

        document.addEventListener('DOMContentLoaded', function () {
            // Remove the integration tab
            const integrationTab = document.getElementById('integrationTab');
            if (integrationTab) {
                integrationTab.remove();
            }
            
            // Remove the integration tab content
            const integrationTabContent = document.getElementById('integration-tab');
            if (integrationTabContent) {
                integrationTabContent.remove();
            }
            
            document.querySelectorAll('.chat-app-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    const fields = document.getElementById(this.value + '-fields');
                    fields.style.display = this.checked ? 'block' : 'none';
                });
            });

            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    // Clips tab requires SFTP settings
                    if (this.dataset.tab === 'clips-tab') {
                        loadSftpSettings();
                    }
                    
                    document.querySelectorAll('.tab, .tab-content').forEach(el => el.classList.remove('active'));
                    this.classList.add('active');
                    document.getElementById(this.dataset.tab).classList.add('active');
                    
                    // Load clips when switching to clips tab
                    if (this.dataset.tab === 'clips-tab' && sftpSettings) {
                        fetchClips();
                    }
                });
            });

            document.getElementById('saveBtn').addEventListener('click', function () {
                const formData = collectFormData();
                
                // Validate required fields
                const errors = [];
                
                // Check that at least one chat app is selected
                if (!formData.chat_app) {
                    errors.push("Please select at least one destination for your clip");
                }
                
                // Validate platform-specific required fields
                if (formData.chat_app.includes('telegram')) {
                    if (!formData.telegram_bot_token || !formData.telegram_chat_id) {
                        errors.push("Telegram requires both Bot Token and Chat ID");
                    }
                }
                
                if (formData.chat_app.includes('mattermost')) {
                    if (!formData.mattermost_url || !formData.mattermost_token || !formData.mattermost_channel) {
                        errors.push("Mattermost requires URL, API Token, and Channel ID");
                    }
                }
                
                if (formData.chat_app.includes('discord')) {
                    if (!formData.discord_webhook_url) {
                        errors.push("Discord requires a Webhook URL");
                    }
                }
                
                if (formData.chat_app.includes('sftp')) {
                    if (!formData.sftp_host || !formData.sftp_user || !formData.sftp_password) {
                        errors.push("SFTP requires Host, Username, and Password");
                    }
                }
                
                // Show errors if any
                if (errors.length > 0) {
                    alert(errors.join(". "));
                    return;
                }
                
                // Save valid data
                savedData = formData;
                localStorage.setItem('configSettings', JSON.stringify(savedData));
                
                alert('Configuration saved!');
                
                // Show integration section when config is saved
                updateIntegrationSection();
            });

            document.getElementById('recordBtn').addEventListener('click', function (e) {
                e.preventDefault();
                recordClip();
            });

            document.querySelectorAll('.copy-btn').forEach(button => {
                button.addEventListener('click', function () {
                    const targetId = this.getAttribute('data-target');
                    const text = document.getElementById(targetId).textContent;
                    navigator.clipboard.writeText(text)
                        .then(() => {
                            const original = this.textContent;
                            this.textContent = 'Copied!';
                            setTimeout(() => { this.textContent = original; }, 1500);
                        });
                });
            });
            
            // Initialize settings
            loadSavedData();
            loadSftpSettings();
            
            // Setup WebSocket or polling
            if ("WebSocket" in window) {
                setupWebSocket();
            } else {
                setupPolling();
            }
            
            // Keyboard shortcuts for player
            document.addEventListener('keydown', (e) => {
                const player = document.getElementById('clip-player');
                const container = document.getElementById('clip-player-container');
                
                // Only handle keys if player is visible
                if (container.style.display === 'none') return;
                
                switch (e.key) {
                    case 'Escape':
                        closePlayer();
                        break;
                    case ' ':
                        if (player.paused) player.play();
                        else player.pause();
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        player.currentTime += 5;
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        player.currentTime -= 5;
                        e.preventDefault();
                        break;
                }
            });

            // Add fullscreen button functionality
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            
            // Update fullscreen icon when fullscreen state changes
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
            document.addEventListener('MSFullscreenChange', updateFullscreenIcon);
            
            function updateFullscreenIcon() {
                const isFullscreen = document.fullscreenElement || 
                                    document.webkitFullscreenElement || 
                                    document.mozFullScreenElement ||
                                    document.msFullscreenElement;
                
                const iconElement = document.querySelector('#fullscreenBtn i');
                if (isFullscreen) {
                    iconElement.className = 'mdi mdi-fullscreen-exit';
                    document.querySelector('.fullscreen-btn').title = 'Exit Fullscreen';
                } else {
                    iconElement.className = 'mdi mdi-fullscreen';
                    document.querySelector('.fullscreen-btn').title = 'Enter Fullscreen';
                }
            }
        });

        function loadSftpSettings() {
            const saved = localStorage.getItem('sftpSettings');
            if (saved) {
                try {
                    sftpSettings = JSON.parse(saved);
                    document.getElementById('sftp_host_config').value = sftpSettings.sftp_host || '';
                    document.getElementById('sftp_port_config').value = sftpSettings.sftp_port || '';
                    document.getElementById('sftp_user_config').value = sftpSettings.sftp_user || '';
                    document.getElementById('sftp_password_config').value = sftpSettings.sftp_password || '';
                    document.getElementById('sftp_path_config').value = sftpSettings.sftp_path || '';
                    showClipsSection();
                } catch (e) {
                    console.error("Error loading SFTP settings:", e);
                    localStorage.removeItem('sftpSettings');
                }
            }
        }

        function saveSftpSettings() {
            const host = document.getElementById('sftp_host_config').value.trim();
            const port = document.getElementById('sftp_port_config').value.trim() || '22';
            const user = document.getElementById('sftp_user_config').value.trim();
            const password = document.getElementById('sftp_password_config').value;
            const path = document.getElementById('sftp_path_config').value.trim() || './';
            
            if (!host || !user || !password) {
                alert('All SFTP fields are required except port and path (which have defaults)');
                return;
            }
            
            sftpSettings = {
                sftp_host: host,
                sftp_port: port,
                sftp_user: user,
                sftp_password: password,
                sftp_path: path
            };
            
            localStorage.setItem('sftpSettings', JSON.stringify(sftpSettings));
            alert('SFTP settings saved!');
            showClipsSection();
            fetchClips();
        }

        function testSftpConnection() {
            const host = document.getElementById('sftp_host_config').value.trim();
            const port = document.getElementById('sftp_port_config').value.trim() || '22';
            const user = document.getElementById('sftp_user_config').value.trim();
            const password = document.getElementById('sftp_password_config').value;
            const path = document.getElementById('sftp_path_config').value.trim() || './';
            
            if (!host || !user || !password) {
                alert('All SFTP fields are required except port and path (which have defaults)');
                return;
            }
            
            const testSettings = {
                sftp_host: host,
                sftp_port: port,
                sftp_user: user,
                sftp_password: password,
                sftp_path: path
            };
            
            document.getElementById('testSftpBtn').disabled = true;
            document.getElementById('testSftpBtn').innerHTML = '<span class="spinner"></span> Testing...';
            
            fetch('/api/clips/test', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(testSettings)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('SFTP connection successful!');
                } else {
                    throw new Error(data.message || 'Connection failed');
                }
            })
            .catch(err => {
                alert('SFTP connection failed: ' + (err.message || err));
            })
            .finally(() => {
                document.getElementById('testSftpBtn').disabled = false;
                document.getElementById('testSftpBtn').innerHTML = 'Test Connection';
            });
        }

        function showClipsSection() {
            document.getElementById('sftp-config').style.display = sftpSettings ? 'none' : 'block';
            document.getElementById('clips-section').style.display = sftpSettings ? 'block' : 'none';
        }

        function fetchClips() {
            if (!sftpSettings) return;
            
            document.getElementById('clips-loading').style.display = 'block';
            document.getElementById('clips-list').innerHTML = '';
            document.getElementById('refreshClipsBtn').querySelector('.spinner').style.display = 'inline-block';
            
            fetch('/api/clips', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(sftpSettings)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                allClips = data.map(clip => {
                    const parsed = parseClipName(clip.name);
                    return {
                        ...clip,
                        ...parsed,
                        timestamp: new Date(clip.mod_time)
                    };
                });
                applyFilters();
            })
            .catch(err => {
                alert('Failed to fetch clips: ' + err);
                document.getElementById('clips-list').innerHTML = '<div class="no-clips">Error loading clips. Please check your connection and try again.</div>';
            })
            .finally(() => {
                document.getElementById('clips-loading').style.display = 'none';
                document.getElementById('refreshClipsBtn').querySelector('.spinner').style.display = 'none';
            });
        }

        function parseClipName(filename) {
            // Replace .mp4 extension and split by underscore
            const parts = filename.replace(/\.mp4$/i, '').split('_');
            
            // Find date part (format: YYYY-MM-DD)
            const dateIndex = parts.findIndex(part => /^\d{4}-\d{2}-\d{2}/.test(part));
            if (dateIndex === -1) {
                return { title: '', category: '', team1: '', team2: '' };
            }
            
            // Extract timestamp parts
            const dateStr = parts[dateIndex];
            const timeStr = parts[dateIndex + 1] || '00-00';
            
            // Parse title, category and teams
            let title = '', category = '', team1 = '', team2 = '';
            
            if (dateIndex > 0) {
                // First part is the title in the new format
                title = parts[0];
                
                // If we have at least 3 parts before the date (title, category, and something else)
                if (dateIndex > 1) {
                    // Second part is the category
                    category = parts[1];
                    
                    // Check for team vs team format in the remaining parts
                    const remainingParts = parts.slice(2, dateIndex).join('_');
                    const teamMatch = remainingParts.match(/(.+)_vs_(.+)/);
                    
                    if (teamMatch) {
                        team1 = teamMatch[1];
                        team2 = teamMatch[2];
                    } else if (dateIndex > 2) {
                        // If no vs pattern but there are parts between category and date,
                        // assume it's just team1
                        team1 = remainingParts;
                    }
                }
            }
            
            // Convert underscores to spaces for display
            title = title.replace(/_/g, ' ');
            category = category.replace(/_/g, ' ');
            team1 = team1.replace(/_/g, ' ');
            team2 = team2.replace(/_/g, ' ');
            
            // If title is empty but category exists, use category as title
            if (!title && category) {
                title = category;
            }
            // If category is empty but title exists, use title as category
            if (!category && title) {
                category = title;
            }
            
            return { title, category, team1, team2, dateStr, timeStr };
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
        }

        function applyFilters() {
            const titleFilter = document.getElementById('filter_title').value.toLowerCase();
            const categoryFilter = document.getElementById('filter_category').value.toLowerCase();
            const teamFilter = document.getElementById('filter_team').value.toLowerCase();
            const startDateFilter = document.getElementById('filter_start_date').value;
            const endDateFilter = document.getElementById('filter_end_date').value;
            
            filteredClips = allClips.filter(clip => {
                // Title filter - less strict matching
                if (titleFilter && !(
                    clip.title.toLowerCase().includes(titleFilter) || 
                    titleFilter.split(' ').some(word => 
                        word.length > 2 && clip.title.toLowerCase().includes(word.toLowerCase())
                    )
                )) {
                    return false;
                }
                
                // Category filter - less strict matching
                if (categoryFilter && !(
                    clip.category.toLowerCase().includes(categoryFilter) || 
                    categoryFilter.split(' ').some(word => 
                        word.length > 2 && clip.category.toLowerCase().includes(word.toLowerCase())
                    )
                )) {
                    return false;
                }
                
                // Team filter - less strict matching for both teams
                if (teamFilter) {
                    const teamWords = teamFilter.split(' ').filter(word => word.length > 2);
                    const team1Matches = teamWords.some(word => clip.team1.toLowerCase().includes(word));
                    const team2Matches = teamWords.some(word => clip.team2.toLowerCase().includes(word));
                    
                    if (!(clip.team1.toLowerCase().includes(teamFilter) || 
                          clip.team2.toLowerCase().includes(teamFilter) ||
                          team1Matches || team2Matches)) {
                        return false;
                    }
                }
                
                // Date filters
                if (startDateFilter) {
                    const startDate = new Date(startDateFilter);
                    if (clip.timestamp < startDate) return false;
                }
                
                if (endDateFilter) {
                    const endDate = new Date(endDateFilter);
                    endDate.setHours(23, 59, 59, 999); // End of day
                    if (clip.timestamp > endDate) return false;
                }
                
                return true;
            });
            
            // Sort by most recent first
            filteredClips.sort((a, b) => b.timestamp - a.timestamp);
            
            // Reset to first page
            currentPage = 1;
            renderClips();
        }

        function renderClips() {
            const clipsList = document.getElementById('clips-list');
            const startIdx = (currentPage - 1) * itemsPerPage;
            const endIdx = startIdx + itemsPerPage;
            const clipsToShow = filteredClips.slice(startIdx, endIdx);
            
            clipsList.innerHTML = '';
            
            if (filteredClips.length === 0) {
                clipsList.innerHTML = '<div class="no-clips">No clips match your filter criteria</div>';
                document.getElementById('pagination').innerHTML = '';
                return;
            }
            
            clipsToShow.forEach(clip => {
                const clipElement = document.createElement('div');
                clipElement.className = 'clip-item';
                
                const timestamp = clip.timestamp.toLocaleDateString() + ' ' +
                                 clip.timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                
                // Always show title
                let displayTitle = clip.title || clip.category || 'Clip';
                
                let teams = '';
                if (clip.team1 && clip.team2) {
                    teams = `${clip.team1} vs ${clip.team2}`;
                } else if (clip.team1) {
                    teams = clip.team1;
                } else if (clip.team2) {
                    teams = clip.team2;
                }
                
                const videoUrl = `/api/clip/stream?path=${encodeURIComponent(clip.path)}&${new URLSearchParams({
                    sftp_host: sftpSettings.sftp_host,
                    sftp_port: sftpSettings.sftp_port,
                    sftp_user: sftpSettings.sftp_user,
                    sftp_password: sftpSettings.sftp_password
                })}`;
                
                clipElement.innerHTML = `
                    <div class="clip-preview-container">
                        <video class="clip-preview" preload="metadata" data-path="${clip.path}" muted poster="/static/img/loading-thumbnail.png">
                            <source src="${videoUrl}" type="video/mp4">
                        </video>
                        <button class="play-btn" data-path="${clip.path}">▶</button>
                    </div>
                    <div class="clip-info">
                        <div class="clip-title">${displayTitle}</div>
                        <div class="clip-metadata">${clip.category}</div>
                        ${teams ? `<div class="clip-metadata">${teams}</div>` : ''}
                        <div class="clip-metadata">${timestamp}</div>
                        <div class="clip-metadata">${formatFileSize(clip.size)}</div>
                    </div>
                    <div class="clip-actions">
                        <button class="upload-btn" data-path="${clip.path}">Upload</button>
                        <button class="download-clip-btn" data-path="${clip.path}" data-name="${clip.name}">Download</button>
                        <button class="edit-clip-btn" data-path="${clip.path}" data-title="${clip.title}" data-category="${clip.category}">Edit</button>
                        <button class="delete-clip-btn" data-path="${clip.path}">Delete</button>
                    </div>
                `;
                
                clipsList.appendChild(clipElement);
                
                // Add event listeners
                const video = clipElement.querySelector('video');
                const playBtn = clipElement.querySelector('.play-btn');
                const uploadBtn = clipElement.querySelector('.upload-btn');
                const downloadBtn = clipElement.querySelector('.download-clip-btn');
                const deleteBtn = clipElement.querySelector('.delete-clip-btn');
                
                video.addEventListener('loadedmetadata', () => {
                    video.currentTime = 1; // Set to 1 second to get a meaningful preview
                });
                
                video.addEventListener('click', () => {
                    playClip(clip.path);
                });
                
                playBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    playClip(clip.path);
                });
                
                uploadBtn.addEventListener('click', () => {
                    // Get the clip information
                    const clipPath = uploadBtn.getAttribute('data-path');
                    const clip = filteredClips.find(c => c.path === clipPath);
                    if (!clip) {
                        alert("Error: Could not find clip data");
                        return;
                    }
                    
                    // Store current clip for access in the upload handler
                    currentClip = clip;
                    
                    const token = localStorage.getItem('yt_access_token');
                    if (!token) {
                        if (confirm('You need to connect your YouTube account first. Do you want to do that now?')) {
                            signInYouTube().then(() => {
                                openYouTubeUploadModal(clip);
                            }).catch(err => {
                                alert('YouTube sign-in failed: ' + (err.error || err.message || 'Unknown error'));
                            });
                        }
                        return;
                    }
                    
                    // Open the YouTube upload modal
                    openYouTubeUploadModal(clip);
                });
                
                downloadBtn.addEventListener('click', () => {
                    downloadClip(clip.path, clip.name);
                });
                
                deleteBtn.addEventListener('click', () => {
                    deleteClip(clip.path, clip.name);
                });
            });
            
            renderPagination();
        }

        function renderPagination() {
            const paginationEl = document.getElementById('pagination');
            paginationEl.innerHTML = '';
            
            if (filteredClips.length <= itemsPerPage) return;
            
            const totalPages = Math.ceil(filteredClips.length / itemsPerPage);
            
            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.innerText = '← Prev';
            prevBtn.disabled = currentPage === 1;
            prevBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderClips();
                }
            });
            paginationEl.appendChild(prevBtn);
            
            // Page info
            const pageInfo = document.createElement('span');
            pageInfo.innerText = `Page ${currentPage} of ${totalPages}`;
            paginationEl.appendChild(pageInfo);
            
            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.innerText = 'Next →';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderClips();
                }
            });
            paginationEl.appendChild(nextBtn);
        }

        function playClip(path) {
            const player = document.getElementById('clip-player');
            const container = document.getElementById('clip-player-container');
            
            const videoUrl = `/api/clip/stream?path=${encodeURIComponent(path)}&${new URLSearchParams({
                sftp_host: sftpSettings.sftp_host,
                sftp_port: sftpSettings.sftp_port,
                sftp_user: sftpSettings.sftp_user,
                sftp_password: sftpSettings.sftp_password
            })}`;
            
            player.src = videoUrl;
            container.style.display = 'block';
            player.classList.add('fullscreen');
            
            // Add ended event listener to auto-close the player when video completes
            player.addEventListener('ended', closePlayer);
            
            // Focus the player for keyboard controls
            player.focus();
            player.play();
        }

        function closePlayer() {
            const player = document.getElementById('clip-player');
            const container = document.getElementById('clip-player-container');
            player.pause();
            player.src = '';
            container.style.display = 'none';
            player.classList.remove('fullscreen');
            
            // Remove the ended event listener to prevent memory leaks
            player.removeEventListener('ended', closePlayer);
        }

        function downloadClip(path, filename) {
            const downloadUrl = `/api/clip/stream?path=${encodeURIComponent(path)}&${new URLSearchParams({
                sftp_host: sftpSettings.sftp_host,
                sftp_port: sftpSettings.sftp_port || "22",
                sftp_user: sftpSettings.sftp_user,
                sftp_password: sftpSettings.sftp_password,
                download: 'true'
            })}`;
            
            const link = document.createElement('a');
            link.href = downloadUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function deleteClip(path, filename) {
            if (!confirm(`Are you sure you want to delete "${filename}"?`)) return;
            
            fetch('/api/clips/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    ...sftpSettings,
                    path: path
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Remove from arrays
                allClips = allClips.filter(clip => clip.path !== path);
                filteredClips = filteredClips.filter(clip => clip.path !== path);
                
                // Re-render with current filters
                renderClips();
                
                alert(`"${filename}" deleted successfully`);
            })
            .catch(err => {
                alert('Failed to delete clip: ' + err);
            });
        }

        function setupWebSocket() {
            // Close any existing connection
            if (ws) {
                ws.close();
            }
            
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;
            console.log('Attempting WebSocket connection to:', wsUrl);
            
            try {
                // Add connection timeout handling
                const connectionTimeout = setTimeout(() => {
                    console.error('WebSocket connection timed out');
                    if (ws && ws.readyState === WebSocket.CONNECTING) {
                        ws.close();
                    }
                }, 10000); // 10 second timeout
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('WebSocket connection established');
                    clearTimeout(connectionTimeout);
                    
                    // Reset reconnection attempts counter on successful connection
                    ws._reconnectionAttempts = 0;
                    
                    // Stop polling if we have a WebSocket connection
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                    }
                    
                    // Send an initial message to verify two-way communication
                    try {
                        ws.send(JSON.stringify({type: "hello", client: "browser"}));
                        console.log("Sent initial hello message");
                        
                        // Send a ping message every 30 seconds
                        ws._pingInterval = setInterval(() => {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                try {
                                    console.log('Sending WebSocket ping');
                                    ws.send(JSON.stringify({type: "ping", timestamp: Date.now()}));
                                } catch (pingErr) {
                                    console.error('Error sending ping:', pingErr);
                                    clearInterval(ws._pingInterval);
                                }
                            } else if (ws) {
                                console.warn('WebSocket not open for ping, state:', ws.readyState);
                                clearInterval(ws._pingInterval);
                            }
                        }, 30000);
                    } catch (e) {
                        console.error('Error in onopen handler:', e);
                    }
                };
                
                ws.onmessage = (event) => {
                    try {
                        console.log('Raw message received:', event.data);
                        const data = JSON.parse(event.data);
                        console.log('WebSocket message received:', data);
                        
                        // Handle ping/pong to keep connection alive
                        if (data.type === "pong") {
                            console.log('Received pong from server');
                            return;
                        }
                        
                        // Refresh clips list if it's a new clip notification
                        if (data.clip_path) {
                            console.log('New clip notification received for path:', data.clip_path);
                            
                            // First refresh the clip list
                            fetchClips();
                            
                            // Add a delay to ensure the clip is properly fetched and available
                            setTimeout(() => {
                                console.log('Attempting to play new clip:', data.clip_path);
                                const playerContainer = document.getElementById('clip-player-container');
                                
                                // Make sure we're not already playing something
                                if (playerContainer.style.display === 'none') {
                                    // Ensure the clip path is properly formatted for playback
                                    playClip(data.clip_path);
                                    console.log('Triggered playback for new clip');
                                } else {
                                    console.log('Player already active, skipping auto-play of new clip');
                                }
                            }, 1500); // Increased delay to ensure the clip is available
                        }
                    } catch (e) {
                        console.error('Error processing WebSocket message:', e, 'Raw message:', event.data);
                    }
                };
                
                ws.onclose = (event) => {
                    console.log('WebSocket connection closed', {
                        code: event.code, 
                        reason: event.reason,
                        wasClean: event.wasClean
                    });
                    
                    clearTimeout(connectionTimeout);
                    
                    // Clear ping interval
                    if (ws._pingInterval) {
                        clearInterval(ws._pingInterval);
                        ws._pingInterval = null;
                    }
                    
                    // Implement exponential backoff for reconnection
                    ws._reconnectionAttempts = (ws._reconnectionAttempts || 0) + 1;
                    const maxDelay = Math.min(30000, Math.pow(2, ws._reconnectionAttempts) * 1000);
                    const reconnectDelay = Math.min(5000, Math.random() * maxDelay);
                    
                    console.log(`Reconnecting (attempt ${ws._reconnectionAttempts}) in ${reconnectDelay}ms`);
                    setTimeout(setupWebSocket, reconnectDelay);
                    
                    // Start polling as fallback if not already polling
                    if (!pollingInterval) {
                        setupPolling();
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    clearTimeout(connectionTimeout);
                    
                    // Log socket state
                    console.log('WebSocket readyState:', ws.readyState);
                    
                    // Start polling as fallback if not already polling
                    if (!pollingInterval) {
                        setupPolling();
                    }
                };
            } catch (e) {
                console.error('Error creating WebSocket connection:', e);
                // Start polling as fallback
                setupPolling();
            }
        }

        function setupPolling() {
            // Check for new clips every 30 seconds
            pollingInterval = setInterval(() => {
                if (sftpSettings) {
                    console.log('Polling for new clips...');
                    fetchClips();
                }
            }, 30000);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Existing event listeners...
            
            // New event listeners for clips tab
            document.getElementById('saveSftpBtn').addEventListener('click', saveSftpSettings);
            document.getElementById('testSftpBtn').addEventListener('click', testSftpConnection);
            document.getElementById('refreshClipsBtn').addEventListener('click', fetchClips);
            document.getElementById('applyFilterBtn').addEventListener('click', applyFilters);
            document.getElementById('save-edit-btn').addEventListener('click', saveClipEdits);
            
            // Event delegation for edit buttons that are dynamically added
            document.addEventListener('click', function(e) {
                if (e.target && e.target.classList.contains('edit-clip-btn')) {
                    const path = e.target.getAttribute('data-path');
                    const title = e.target.getAttribute('data-title');
                    const category = e.target.getAttribute('data-category');
                    openEditModal(path, title, category);
                }
            });
            
            document.getElementById('resetFilterBtn').addEventListener('click', () => {
                document.getElementById('filter_title').value = '';
                document.getElementById('filter_category').value = '';
                document.getElementById('filter_team').value = '';
                document.getElementById('filter_start_date').value = '';
                document.getElementById('filter_end_date').value = '';
                applyFilters();
            });
            
            document.querySelector('.close-player').addEventListener('click', closePlayer);
            
            // Tab handling
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    // Integration tab requires saved data
                    if (this.dataset.tab === 'integration-tab' && !savedData) {
                        alert('Please save your configuration first.');
                        return;
                    }
                    
                    // Clips tab requires SFTP settings
                    if (this.dataset.tab === 'clips-tab') {
                        loadSftpSettings();
                    }
                    
                    document.querySelectorAll('.tab, .tab-content').forEach(el => el.classList.remove('active'));
                    this.classList.add('active');
                    document.getElementById(this.dataset.tab).classList.add('active');
                    
                    // Load clips when switching to clips tab
                    if (this.dataset.tab === 'clips-tab' && sftpSettings) {
                        fetchClips();
                    }
                });
            });
            
            // Initialize clips view if needed
            loadSftpSettings();
            
            // Setup WebSocket or polling
            if ("WebSocket" in window) {
                setupWebSocket();
            } else {
                setupPolling();
            }
            
            // Keyboard shortcuts for player
            document.addEventListener('keydown', (e) => {
                const player = document.getElementById('clip-player');
                const container = document.getElementById('clip-player-container');
                
                // Only handle keys if player is visible
                if (container.style.display === 'none') return;
                
                switch (e.key) {
                    case 'Escape':
                        closePlayer();
                        break;
                    case ' ':
                        if (player.paused) player.play();
                        else player.pause();
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        player.currentTime += 5;
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        player.currentTime -= 5;
                        e.preventDefault();
                        break;
                }
            });
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement && 
                !document.mozFullScreenElement && 
                !document.webkitFullscreenElement && 
                !document.msFullscreenElement) {
                // Enter fullscreen
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                } else if (document.documentElement.mozRequestFullScreen) {
                    document.documentElement.mozRequestFullScreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
            // The icon will be updated by the fullscreenchange event handler
        }
        
        // YouTube Auth + Upload JS
        const YT_CLIENT_ID = '177621281701-i482ftiuvtg25u0pi76v90o9ji9t133d.apps.googleusercontent.com';
        let currentClip = null;
        let tokenClient = null;
        
        function initYouTubeAuth() {
            // Initialize the token client for OAuth 2.0 implicit flow
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: YT_CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/youtube.upload',
                callback: (tokenResponse) => {
                    if (tokenResponse && tokenResponse.access_token) {
                        // Store the access token
                        const accessToken = tokenResponse.access_token;
                        localStorage.setItem('yt_access_token', accessToken);
                        
                        // Fetch user info from YouTube API
                        fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', {
                            headers: { 'Authorization': `Bearer ${accessToken}` }
                        })
                        .then(response => response.json())
                        .then(data => {
                            let channelName = 'YouTube Account';
                            if (data.items && data.items.length > 0) {
                                channelName = data.items[0].snippet.title;
                            }
                            
                            // Update UI
                            document.getElementById('ytStatus').innerText = `Signed in as: ${channelName}`;
                            document.getElementById('signInYouTube').style.display = 'none';
                            document.getElementById('signOutYouTube').style.display = 'block';
                            
                            // If there's a pending upload, continue with it
                            if (currentClip) {
                                openYouTubeUploadModal(currentClip);
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching channel info:', error);
                            document.getElementById('ytStatus').innerText = 'Signed in (channel info unavailable)';
                            document.getElementById('signInYouTube').style.display = 'none';
                            document.getElementById('signOutYouTube').style.display = 'block';
                        });
                    } else {
                        console.error('No access token received');
                        document.getElementById('ytStatus').innerText = 'Authentication failed';
                    }
                },
                error_callback: (error) => {
                    console.error('GIS Auth Error:', error);
                    document.getElementById('ytStatus').innerText = `Error: ${error.type || 'Authentication failed'}`;
                }
            });

            // Check if we have a token in localStorage and verify it
            const storedToken = localStorage.getItem('yt_access_token');
            if (storedToken) {
                verifyToken(storedToken);
            } else {
                document.getElementById('ytStatus').innerText = 'Not signed in';
                document.getElementById('signInYouTube').style.display = 'block';
                document.getElementById('signOutYouTube').style.display = 'none';
            }
        }
        
        function verifyToken(token) {
            // Attempt to get channel info to verify token validity
            fetch('https://www.googleapis.com/youtube/v3/channels?part=snippet&mine=true', {
                headers: { 'Authorization': `Bearer ${token}` }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Token invalid or expired');
                }
                return response.json();
            })
            .then(data => {
                let channelName = 'YouTube Account';
                if (data.items && data.items.length > 0) {
                    channelName = data.items[0].snippet.title;
                }
                
                document.getElementById('ytStatus').innerText = `Signed in as: ${channelName}`;
                document.getElementById('signInYouTube').style.display = 'none';
                document.getElementById('signOutYouTube').style.display = 'block';
            })
            .catch(error => {
                console.error('Token verification failed:', error);
                localStorage.removeItem('yt_access_token');
                document.getElementById('ytStatus').innerText = 'Not signed in';
                document.getElementById('signInYouTube').style.display = 'block';
                document.getElementById('signOutYouTube').style.display = 'none';
            });
        }
        
        function signInYouTube() {
            return new Promise((resolve, reject) => {
                if (!tokenClient) {
                    reject(new Error('Google Identity Services not initialized'));
                    return;
                }

                // Store a reference to the resolve/reject functions for later
                tokenClient._resolve = resolve;
                tokenClient._reject = reject;
                
                // Request an access token, trigger the OAuth flow
                tokenClient.requestAccessToken({
                    prompt: 'consent',  // Always ask for consent to allow account switching
                });
            });
        }
        
        function signOutYouTube() {
            const token = localStorage.getItem('yt_access_token');
            if (token) {
                // Revoke the token
                google.accounts.oauth2.revoke(token, () => {
                    localStorage.removeItem('yt_access_token');
                    document.getElementById('ytStatus').innerText = 'Not signed in';
                    document.getElementById('signInYouTube').style.display = 'block';
                    document.getElementById('signOutYouTube').style.display = 'none';
                    console.log('YouTube token revoked and removed');
                });
            } else {
                document.getElementById('ytStatus').innerText = 'Not signed in';
                document.getElementById('signInYouTube').style.display = 'block';
                document.getElementById('signOutYouTube').style.display = 'none';
            }
        }
        
        function openYouTubeUploadModal(clip) {
            currentClip = clip;
            document.getElementById('yt-title').value = clip.name.replace(/\.mp4$/, '');
            
            // Default description based on clip metadata
            let description = '';
            if (clip.category) description += `Category: ${clip.category}\n`;
            if (clip.team1 && clip.team2) description += `Match: ${clip.team1} vs ${clip.team2}\n`;
            else if (clip.team1) description += `Team: ${clip.team1}\n`;
            else if (clip.team2) description += `Team: ${clip.team2}\n`;
            description += `Date: ${clip.timestamp.toLocaleDateString()}`;
            
            document.getElementById('yt-description').value = description;
            document.getElementById('yt-privacy').value = 'private';
            document.getElementById('yt-upload-status').innerText = '';
            document.getElementById('youtube-upload-modal').style.display = 'flex';
        }
        
        function closeYouTubeModal() {
            document.getElementById('youtube-upload-modal').style.display = 'none';
        }
        
        async function uploadClipToYouTube() {
            const token = localStorage.getItem('yt_access_token');
            if (!token || !currentClip) return;
            
            const title = document.getElementById('yt-title').value;
            const description = document.getElementById('yt-description').value;
            const privacy = document.getElementById('yt-privacy').value;
            
            document.getElementById('yt-upload-status').innerText = 'Fetching video...';
            
            try {
                // Fetch file from backend
                const params = new URLSearchParams({
                    sftp_host: sftpSettings.sftp_host,
                    sftp_port: sftpSettings.sftp_port || "22",
                    sftp_user: sftpSettings.sftp_user,
                    sftp_password: sftpSettings.sftp_password,
                    path: currentClip.path
                });
                
                const fileResponse = await fetch(`/api/clip/stream?${params}`);
                const blob = await fileResponse.blob();
                
                document.getElementById('yt-upload-status').innerText = 'Preparing upload...';
                
                const initRes = await fetch('https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        'X-Upload-Content-Length': blob.size,
                        'X-Upload-Content-Type': blob.type
                    },
                    body: JSON.stringify({
                        snippet: { title, description },
                        status: { privacyStatus: privacy }
                    })
                });
                
                if (!initRes.ok) {
                    throw new Error('YouTube initialization failed.');
                }
                
                document.getElementById('yt-upload-status').innerText = 'Uploading...';
                
                const uploadUrl = initRes.headers.get('Location');
                const uploadRes = await fetch(uploadUrl, {
                    method: 'PUT',
                    headers: { 'Content-Type': blob.type },
                    body: blob
                });
                
                if (uploadRes.ok) {
                    const data = await uploadRes.json();
                    const videoId = data.id;
                    document.getElementById('yt-upload-status').innerText = 'Upload complete!';
                    setTimeout(() => {
                        closeYouTubeModal();
                        alert(`Video uploaded to YouTube!`);
                    }, 2000);
                } else {
                    const err = await uploadRes.json();
                    throw new Error('Upload error: ' + (err.error && err.error.message ? err.error.message : 'unknown'));
                }
            } catch (error) {
                document.getElementById('yt-upload-status').innerText = `Error: ${error.message}`;
                console.error('YouTube upload failed:', error);
            }
        }
        
        // Event listeners for YouTube functionality
        window.addEventListener('load', () => {
            initYouTubeAuth();
            
            document.getElementById('signInYouTube').addEventListener('click', signInYouTube);
            document.getElementById('signOutYouTube').addEventListener('click', signOutYouTube);
            document.getElementById('yt-upload-btn').addEventListener('click', uploadClipToYouTube);
        });

        // Edit clip functionality
        let currentEditClip = null;
        
        function openEditModal(path, title, category) {
            currentEditClip = { path, title, category };
            document.getElementById('edit-title').value = title || '';
            document.getElementById('edit-category').value = category || '';
            document.getElementById('edit-status').innerText = '';
            document.getElementById('edit-clip-modal').style.display = 'flex';
        }
        
        function closeEditModal() {
            document.getElementById('edit-clip-modal').style.display = 'none';
            currentEditClip = null;
        }
        
        async function saveClipEdits() {
            if (!currentEditClip || !sftpSettings) return;
            
            const newTitle = document.getElementById('edit-title').value.trim();
            const newCategory = document.getElementById('edit-category').value.trim();
            const statusEl = document.getElementById('edit-status');
            
            statusEl.innerText = 'Saving changes...';
            
            try {
                // Get the clip's full details to preserve other metadata
                const clip = allClips.find(c => c.path === currentEditClip.path);
                if (!clip) {
                    throw new Error('Clip not found');
                }
                
                const response = await fetch('/api/clips/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...sftpSettings,
                        path: currentEditClip.path,
                        title: newTitle,
                        category: newCategory
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to save changes: ${errorText}`);
                }
                
                const result = await response.json();
                
                // Update local data with the new name and refresh the UI
                if (result.success) {
                    statusEl.innerText = 'Saved successfully!';
                    
                    // Update in our local array
                    const updatedClip = allClips.find(c => c.path === currentEditClip.path);
                    if (updatedClip) {
                        updatedClip.title = newTitle;
                        updatedClip.category = newCategory;
                        if (result.new_path && result.new_path !== currentEditClip.path) {
                            updatedClip.path = result.new_path;
                            updatedClip.name = result.new_name;
                        }
                    }
                    
                    // Update filtered array too
                    const updatedFilteredClip = filteredClips.find(c => c.path === currentEditClip.path);
                    if (updatedFilteredClip) {
                        updatedFilteredClip.title = newTitle;
                        updatedFilteredClip.category = newCategory;
                        if (result.new_path && result.new_path !== currentEditClip.path) {
                            updatedFilteredClip.path = result.new_path;
                            updatedFilteredClip.name = result.new_name;
                        }
                    }
                    
                    // Re-render the UI
                    renderClips();
                    
                    // Close the modal after a short delay
                    setTimeout(() => {
                        closeEditModal();
                    }, 1500);
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
            } catch (error) {
                statusEl.style.color = 'red';
                statusEl.innerText = `Error: ${error.message}`;
                console.error('Edit clip error:', error);
            }
        }
    </script>
    
    <!-- YouTube Upload Modal -->
    <div id="youtube-upload-modal" class="modal" style="display:none;">
        <div class="modal-content">
            <h3>Upload to YouTube</h3>
            <label for="yt-title">Title:</label>
            <input type="text" id="yt-title" />
            <label for="yt-description">Description:</label>
            <textarea id="yt-description" rows="3"></textarea>
            <label for="yt-privacy">Privacy:</label>
            <select id="yt-privacy">
                <option value="unlisted">Unlisted</option>
                <option value="public">Public</option>
                <option value="private">Private</option>
            </select>
            <div style="margin-top: 1rem;">
                <button id="yt-upload-btn">Upload</button>
                <button onclick="closeYouTubeModal()">Cancel</button>
            </div>
            <div id="yt-upload-status" style="margin-top: 1rem; color: limegreen;"></div>
        </div>
    </div>
    
    <!-- Edit Clip Modal -->
    <div id="edit-clip-modal" class="modal" style="display:none;">
        <div class="modal-content">
            <h3>Edit Clip Details</h3>
            <label for="edit-title">Title:</label>
            <input type="text" id="edit-title" />
            <label for="edit-category">Category:</label>
            <input type="text" id="edit-category" />
            <div style="margin-top: 1rem;">
                <button id="save-edit-btn">Save Changes</button>
                <button onclick="closeEditModal()">Cancel</button>
            </div>
            <div id="edit-status" style="margin-top: 1rem; color: limegreen;"></div>
        </div>
    </div>
</body>
</html>